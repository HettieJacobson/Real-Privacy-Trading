# User Decrypt Multiple Values

```chapter: decryption
```

## Overview

Shows how to decrypt multiple values for a user

## Key Concepts

### Encrypted State Variables
- Trading volumes stored as encrypted values
- Portfolio balances maintained in encrypted form
- Price data encrypted for strategy confidentiality

### Private Computation
- Order matching executed on encrypted data
- Portfolio calculations without decryption
- Confidential balance updates

### Access Control Patterns
- Contract-level permissions with FHE.allowThis()
- User-level permissions with FHE.allow()
- Privacy-preserving portfolio queries

### Confidential Transactions
- Buy/sell orders with encrypted amounts
- Anonymous market participation
- Zero-knowledge execution proofs

## Smart Contract

### Contract File
```
contracts/basic/decrypt/UserDecryptMultipleValues.sol
```

### Key Functions

#### placeOrder
Places a limit order with encrypted amount and price.

```solidity
function placeOrder(
    string memory pair,
    bool isLong,
    uint32 amount,
    uint32 price
) external returns (uint256)
```

#### quickBuy
Executes an instant market buy order.

```solidity
function quickBuy(string memory pair, uint32 amount) external returns (uint256)
```

#### quickSell
Executes an instant market sell order.

```solidity
function quickSell(string memory pair, uint32 amount) external returns (uint256)
```

#### getPortfolioBalance
Retrieves encrypted portfolio balance.

```solidity
function getPortfolioBalance(address trader, string memory pair) external view returns (uint256)
```

## Test Suite

### Test File
```
test/basic/decrypt/UserDecryptMultipleValues.ts
```

### Test Categories

#### ✅ Correct Patterns
- Proper FHE permission granting
- Encrypted value operations
- User-specific decryption workflows
- Order placement and execution

#### ❌ Common Pitfalls
- Missing FHE.allowThis() permission
- Incorrect permission scoping
- Missing input validation
- Unencrypted value operations

## FHEVM Patterns Demonstrated

### Pattern 1: Encrypt and Grant Permissions
```solidity
// ✅ CORRECT: Grant both permissions
euint32 encryptedValue = FHE.asEuint32(userInput);
FHE.allowThis(encryptedValue);           // Contract permission
FHE.allow(encryptedValue, msg.sender);   // User permission
```

### Pattern 2: Operations on Encrypted Values
```solidity
// ✅ CORRECT: Use FHE operations
euint32 currentBalance = portfolios[msg.sender][pair];
euint32 newBalance = FHE.add(currentBalance, encryptedAmount);
portfolios[msg.sender][pair] = newBalance;

FHE.allowThis(newBalance);
FHE.allow(newBalance, msg.sender);
```

### Pattern 3: User Decryption
```solidity
// ✅ CORRECT: User can decrypt own data
function getMyBalance(string memory pair) external view returns (uint256) {
    return portfolios[msg.sender][pair];
}
```

### Pattern 4: Privacy-Preserving Queries
```solidity
// ✅ CORRECT: Only authorized users access data
function getPortfolioBalance(address trader, string memory pair)
    external view returns (uint256) {
    require(msg.sender == trader, "Only owner can view");
    return portfolios[trader][pair];
}
```

## Getting Started

### Installation
```bash
npm install
```

### Compilation
```bash
npm run compile
```

### Testing
```bash
npm run test
```

### Deployment
```bash
npm run deploy:sepolia
```

## Use Cases

### Individual Traders
- Private trading with hidden strategies
- Front-running prevention
- Anonymous market participation

### Institutional Users
- Regulatory compliance
- Competitive advantage protection
- Institutional-grade privacy

### Privacy Advocates
- Financial privacy
- Data sovereignty
- Decentralized privacy

## Common Errors and Solutions

### Error: "Unauthorized access to encrypted value"
```
Solution: Add FHE.allowThis() and FHE.allow() after creating encrypted values
```

### Error: "Input proof verification failed"
```
Solution: Ensure encrypted input was created with correct contract address and user
```

### Error: "Permission denied for decryption"
```
Solution: Verify FHE.allow(value, user) was called for the decrypting user
```

## Learning Resources

- [FHEVM Documentation](https://docs.zama.ai/fhevm)
- [Hardhat Documentation](https://hardhat.org)
- [Solidity Documentation](https://docs.soliditylang.org/)
- [FHE Concepts Guide](https://www.zama.ai/fhevm)

## Summary

This example demonstrates essential FHEVM concepts for building privacy-preserving decentralized applications. It showcases encrypted state management, private computation, and confidential transactions.

By studying this example, developers can learn:
- How to structure privacy-preserving smart contracts
- FHEVM permission patterns and best practices
- Testing strategies for encrypted contracts
- Common pitfalls and how to avoid them

---

Generated by FHEVM Documentation Generator
